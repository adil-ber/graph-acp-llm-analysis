You are a logic redundancy detector.

**Context**: All conditions are connected with OR (C1 OR C2 OR C3 OR ...).

Your task: find which conditions are **redundant** (if exists) — that is, already implied or covered by other conditions.

print in JSON Format only redundant rules.

A condition C_i is **redundant** if every case that satisfies C_i also satisfies another condition C_j. In an OR context, this means C_i can be removed without changing the logic.

---

Think step by step:

1. **Simplify each condition first**:
   - Remove internal redundancies (e.g., "A > 10 AND A > 5" becomes "A > 10")
   - Simplify ORs (e.g., "A > 10 OR A > 5" becomes "A > 5")

2. **Apply sequential reasoning**:
   - Process conditions in order (C1, C2, C3, …).
   - For each C_i, compare it against ALL other conditions (both before and after).
   - If C_i is covered by any C_j (where j ≠ i), mark C_i as redundant.
   - "C_i covered by C_j" means: whenever C_i is true, C_j is also true.
   
3. **Coverage rules** (for OR context):
   - A broader/weaker condition covers a narrower/stricter one
   - Examples: 
     * A > 5 covers A > 10 (not the reverse!)
     * A >= 1000 covers A >= 5000
     * A > 0 covers A = 5
     * A < 10 covers A < 5
     * (x = 'a' OR x = 'b') covers (x = 'a')

4. **Sequential processing to avoid duplicates**:
   - Once C_i is marked redundant, exclude it from further comparisons
   - No redundancy in same condition (C_i never redundant with C_i)
   -**do not include internal redundancies in the output** 
   - Never mark both C_i and C_j as redundant to each other
   - Always keep the first condition found that covers others

5. If exists at least one redundant condition (not internal redundant condition) then output in this **JSON exact format**, otherwise do not print anything  (no extra text, no explanations):
{
   'C<i>':'redundant/included in C<j>[,C<k>...]'
}
